
"                                                   The License
 
 The user is free to produce commercial applications with the software, to distribute these applications in source or binary  form, and to charge monies for them as he sees fit and in concordance with the laws of the land subject to the following  license.
 
 1. The license applies to all the software and all derived software and must appear on such.
 2. It is illegal to distribute the software without this license attached to it and use of the software implies agreement 
    with the license as such. It is illegal for anyone who is not the copyright holder to tamper with or change the license.
 3. Neither the names of Lambda Associates or the copyright holder may be used to endorse or promote products built using
     the software without specific prior written permission from the copyright holder.
 4. That possession of this license does not confer on the copyright holder any special contractual obligation towards the    user. That in no event shall the copyright holder be liable for any direct, indirect, incidental, special, exemplary or   consequential damages (including but not limited to procurement of substitute goods or services, loss of use, data, or    profits; or business interruption), however caused and on any theory of liability, whether in contract, strict liability   or tort (including negligence) arising in any way out of the use of the software, even if advised of the possibility of   such damage. 
5. It is permitted for the user to change the software, for the purpose of improving performance, correcting an error, or    porting to a new platform, and distribute the modified version of Shen (hereafter the modified version) provided the     resulting program conforms in all respects to the Shen standard and is issued under that title. The user must make it clear   with his distribution that he/she is the author of the changes and what these changes are and why. 
6. Derived versions of this software in whatever form are subject to the same restrictions. In particular it is not          permitted to make derived copies of this software which do not conform to the Shen standard or appear under a different title.
7. It is permitted to distribute versions of Shen which incorporate libraries, graphics or other facilities which are not    part of the Shen standard.

For an explication of this license see http://www.lambdassociates.org/News/june11/license.htm which explains this license in full."

(defun shen-<defprolog> (V1124)
 (let Result
  (let Parse_<predicate*> (shen-<predicate*> V1124)
   (if (not (= (fail) Parse_<predicate*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<predicate*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (hd
        (shen-prolog->shen
         (map (lambda X (shen-insert-predicate (snd Parse_<predicate*>) X))
          (snd Parse_<clauses*>)))))
      (fail)))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-prolog-error (V1125 V1126)
 (interror "prolog syntax error in ~A here:~%~% ~A~%"
  (@p V1125 (@p (shen-next-50 50 V1126) ()))))

(defun shen-next-50 (V1131 V1132)
 (cond ((= () V1132) "") ((= 0 V1131) "")
  ((cons? V1132)
   (cn (shen-decons-string (hd V1132)) (shen-next-50 (- V1131 1) (tl V1132))))
  (true (shen-sys-error shen-next-50))))

(defun shen-decons-string (V1133)
 (cond
  ((and (cons? V1133)
    (and (= cons (hd V1133))
     (and (cons? (tl V1133))
      (and (cons? (tl (tl V1133))) (= () (tl (tl (tl V1133))))))))
   (intmake-string "~S " (@p (shen-eval-cons V1133) ())))
  (true (intmake-string "~R " (@p V1133 ())))))

(defun shen-insert-predicate (V1134 V1135)
 (cond
  ((and (cons? V1135) (and (cons? (tl V1135)) (= () (tl (tl V1135)))))
   (cons (cons V1134 (hd V1135)) (cons :- (tl V1135))))
  (true (shen-sys-error shen-insert-predicate))))

(defun shen-<predicate*> (V1136)
 (let Result
  (if (cons? (fst V1136))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1136)) (snd V1136)))
    (hd (fst V1136)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<clauses*> (V1137)
 (let Result
  (let Parse_<clause*> (shen-<clause*> V1137)
   (if (not (= (fail) Parse_<clause*>))
    (let Parse_<clauses*> (shen-<clauses*> Parse_<clause*>)
     (if (not (= (fail) Parse_<clauses*>))
      (shen-reassemble (fst Parse_<clauses*>)
       (cons (snd Parse_<clause*>) (snd Parse_<clauses*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1137)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<clause*> (V1138)
 (let Result
  (let Parse_<head*> (shen-<head*> V1138)
   (if (not (= (fail) Parse_<head*>))
    (if (and (cons? (fst Parse_<head*>)) (= <-- (hd (fst Parse_<head*>))))
     (let Parse_<body*>
      (shen-<body*>
       (shen-reassemble (tl (fst Parse_<head*>)) (snd Parse_<head*>)))
      (if (not (= (fail) Parse_<body*>))
       (let Parse_<end*> (shen-<end*> Parse_<body*>)
        (if (not (= (fail) Parse_<end*>))
         (shen-reassemble (fst Parse_<end*>)
          (cons (snd Parse_<head*>) (cons (snd Parse_<body*>) ())))
         (fail)))
       (fail)))
     (fail))
    (fail)))
  (if (= Result (fail)) (fail) Result)))

(defun shen-<head*> (V1139)
 (let Result
  (let Parse_<term*> (shen-<term*> V1139)
   (if (not (= (fail) Parse_<term*>))
    (let Parse_<head*> (shen-<head*> Parse_<term*>)
     (if (not (= (fail) Parse_<head*>))
      (shen-reassemble (fst Parse_<head*>)
       (cons (snd Parse_<term*>) (snd Parse_<head*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1139)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<term*> (V1140)
 (let Result
  (if (cons? (fst V1140))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1140)) (snd V1140)))
    (if
     (and (not (= <-- (hd (fst V1140))))
      (shen-legitimate-term? (hd (fst V1140))))
     (shen-eval-cons (hd (fst V1140))) (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun shen-legitimate-term? (V1145)
 (cond
  ((and (cons? V1145)
    (and (= cons (hd V1145))
     (and (cons? (tl V1145))
      (and (cons? (tl (tl V1145))) (= () (tl (tl (tl V1145))))))))
   (and (shen-legitimate-term? (hd (tl V1145)))
    (shen-legitimate-term? (hd (tl (tl V1145))))))
  ((and (cons? V1145)
    (and (= mode (hd V1145))
     (and (cons? (tl V1145))
      (and (cons? (tl (tl V1145)))
       (and (= + (hd (tl (tl V1145)))) (= () (tl (tl (tl V1145)))))))))
   (shen-legitimate-term? (hd (tl V1145))))
  ((and (cons? V1145)
    (and (= mode (hd V1145))
     (and (cons? (tl V1145))
      (and (cons? (tl (tl V1145)))
       (and (= - (hd (tl (tl V1145)))) (= () (tl (tl (tl V1145)))))))))
   (shen-legitimate-term? (hd (tl V1145))))
  ((cons? V1145) false) (true true)))

(defun shen-eval-cons (V1146)
 (cond
  ((and (cons? V1146)
    (and (= cons (hd V1146))
     (and (cons? (tl V1146))
      (and (cons? (tl (tl V1146))) (= () (tl (tl (tl V1146))))))))
   (cons (shen-eval-cons (hd (tl V1146)))
    (shen-eval-cons (hd (tl (tl V1146))))))
  ((and (cons? V1146)
    (and (= mode (hd V1146))
     (and (cons? (tl V1146))
      (and (cons? (tl (tl V1146))) (= () (tl (tl (tl V1146))))))))
   (cons mode (cons (shen-eval-cons (hd (tl V1146))) (tl (tl V1146)))))
  (true V1146)))

(defun shen-<body*> (V1147)
 (let Result
  (let Parse_<literal*> (shen-<literal*> V1147)
   (if (not (= (fail) Parse_<literal*>))
    (let Parse_<body*> (shen-<body*> Parse_<literal*>)
     (if (not (= (fail) Parse_<body*>))
      (shen-reassemble (fst Parse_<body*>)
       (cons (snd Parse_<literal*>) (snd Parse_<body*>)))
      (fail)))
    (fail)))
  (if (= Result (fail))
   (let Result
    (let Parse_<e> (<e> V1147)
     (if (not (= (fail) Parse_<e>))
      (shen-reassemble (fst Parse_<e>) (snd Parse_<e>)) (fail)))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<literal*> (V1148)
 (let Result
  (if (and (cons? (fst V1148)) (= ! (hd (fst V1148))))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1148)) (snd V1148)))
    (cons cut (cons Throwcontrol ())))
   (fail))
  (if (= Result (fail))
   (let Result
    (if (cons? (fst V1148))
     (shen-reassemble (fst (shen-reassemble (tl (fst V1148)) (snd V1148)))
      (if (cons? (hd (fst V1148))) (hd (fst V1148)) (fail)))
     (fail))
    (if (= Result (fail)) (fail) Result))
   Result)))

(defun shen-<end*> (V1149)
 (let Result
  (if (cons? (fst V1149))
   (shen-reassemble (fst (shen-reassemble (tl (fst V1149)) (snd V1149)))
    (if (= (hd (fst V1149)) ;) shen-skip (fail)))
   (fail))
  (if (= Result (fail)) (fail) Result)))

(defun cut (V1150 V1151 V1152)
 (let Result (thaw V1152) (if (= Result false) V1150 Result)))

(defun shen-insert_modes (V1153)
 (cond
  ((and (cons? V1153)
    (and (= mode (hd V1153))
     (and (cons? (tl V1153))
      (and (cons? (tl (tl V1153))) (= () (tl (tl (tl V1153))))))))
   V1153)
  ((= () V1153) ())
  ((cons? V1153)
   (cons (cons mode (cons (hd V1153) (cons + ())))
    (cons mode (cons (shen-insert_modes (tl V1153)) (cons - ())))))
  (true V1153)))

(defun shen-s-prolog (V1154)
 (map (lambda V1155 (eval V1155)) (shen-prolog->shen V1154)))

(defun shen-prolog->shen (V1156)
 (map (lambda V1157 (shen-compile_prolog_procedure V1157))
  (shen-group_clauses
   (map (lambda V1158 (shen-s-prolog_clause V1158))
    (mapcan (lambda V1159 (shen-head_abstraction V1159)) V1156)))))

(defun shen-s-prolog_clause (V1160)
 (cond
  ((and (cons? V1160)
    (and (cons? (tl V1160))
     (and (= :- (hd (tl V1160)))
      (and (cons? (tl (tl V1160))) (= () (tl (tl (tl V1160))))))))
   (cons (hd V1160)
    (cons :-
     (cons
      (map (lambda V1161 (shen-s-prolog_literal V1161)) (hd (tl (tl V1160))))
      ()))))
  (true (shen-sys-error shen-s-prolog_clause))))

(defun shen-head_abstraction (V1162)
 (cond
  ((and (cons? V1162)
    (and (cons? (tl V1162))
     (and (= :- (hd (tl V1162)))
      (and (cons? (tl (tl V1162)))
       (and (= () (tl (tl (tl V1162))))
        (< (shen-complexity_head (hd V1162))
         (value shen-*maxcomplexity*)))))))
   (cons V1162 ()))
  ((and (cons? V1162)
    (and (cons? (hd V1162))
     (and (cons? (tl V1162))
      (and (= :- (hd (tl V1162)))
       (and (cons? (tl (tl V1162))) (= () (tl (tl (tl V1162)))))))))
   (let Terms (map (lambda Y (gensym V)) (tl (hd V1162)))
    (let XTerms (shen-rcons_form (shen-remove_modes (tl (hd V1162))))
     (let Literal (cons unify (cons (shen-cons_form Terms) (cons XTerms ())))
      (let Clause
       (cons (cons (hd (hd V1162)) Terms)
        (cons :- (cons (cons Literal (hd (tl (tl V1162)))) ())))
       (cons Clause ()))))))
  (true (shen-sys-error shen-head_abstraction))))

(defun shen-complexity_head (V1167)
 (cond
  ((cons? V1167)
   (shen-product (map (lambda V1168 (shen-complexity V1168)) (tl V1167))))
  (true (shen-sys-error shen-complexity_head))))

(defun shen-complexity (V1176)
 (cond
  ((and (cons? V1176)
    (and (= mode (hd V1176))
     (and (cons? (tl V1176))
      (and (cons? (hd (tl V1176)))
       (and (= mode (hd (hd (tl V1176))))
        (and (cons? (tl (hd (tl V1176))))
         (and (cons? (tl (tl (hd (tl V1176)))))
          (and (= () (tl (tl (tl (hd (tl V1176))))))
           (and (cons? (tl (tl V1176)))
            (= () (tl (tl (tl V1176)))))))))))))
   (shen-complexity (hd (tl V1176))))
  ((and (cons? V1176)
    (and (= mode (hd V1176))
     (and (cons? (tl V1176))
      (and (cons? (hd (tl V1176)))
       (and (cons? (tl (tl V1176)))
        (and (= + (hd (tl (tl V1176))))
         (= () (tl (tl (tl V1176))))))))))
   (* 2
    (*
     (shen-complexity (cons mode (cons (hd (hd (tl V1176))) (tl (tl V1176)))))
     (shen-complexity
      (cons mode (cons (tl (hd (tl V1176))) (tl (tl V1176))))))))
  ((and (cons? V1176)
    (and (= mode (hd V1176))
     (and (cons? (tl V1176))
      (and (cons? (hd (tl V1176)))
       (and (cons? (tl (tl V1176)))
        (and (= - (hd (tl (tl V1176))))
         (= () (tl (tl (tl V1176))))))))))
   (* (shen-complexity (cons mode (cons (hd (hd (tl V1176))) (tl (tl V1176)))))
    (shen-complexity (cons mode (cons (tl (hd (tl V1176))) (tl (tl V1176)))))))
  ((and (cons? V1176)
    (and (= mode (hd V1176))
     (and (cons? (tl V1176))
      (and (cons? (tl (tl V1176)))
       (and (= () (tl (tl (tl V1176)))) (variable? (hd (tl V1176))))))))
   1)
  ((and (cons? V1176)
    (and (= mode (hd V1176))
     (and (cons? (tl V1176))
      (and (cons? (tl (tl V1176)))
       (and (= + (hd (tl (tl V1176)))) (= () (tl (tl (tl V1176)))))))))
   2)
  ((and (cons? V1176)
    (and (= mode (hd V1176))
     (and (cons? (tl V1176))
      (and (cons? (tl (tl V1176)))
       (and (= - (hd (tl (tl V1176)))) (= () (tl (tl (tl V1176)))))))))
   1)
  (true (shen-complexity (cons mode (cons V1176 (cons + ())))))))

(defun shen-product (V1177)
 (cond ((= () V1177) 1)
  ((cons? V1177) (* (hd V1177) (shen-product (tl V1177))))
  (true (shen-sys-error shen-product))))

(defun shen-s-prolog_literal (V1178)
 (cond
  ((and (cons? V1178)
    (and (= is (hd V1178))
     (and (cons? (tl V1178))
      (and (cons? (tl (tl V1178))) (= () (tl (tl (tl V1178))))))))
   (cons bind
    (cons (hd (tl V1178))
     (cons (shen-insert_deref (hd (tl (tl V1178)))) ()))))
  ((and (cons? V1178)
    (and (= when (hd V1178))
     (and (cons? (tl V1178)) (= () (tl (tl V1178))))))
   (cons fwhen (cons (shen-insert_deref (hd (tl V1178))) ())))
  ((and (cons? V1178)
    (and (= bind (hd V1178))
     (and (cons? (tl V1178))
      (and (cons? (tl (tl V1178))) (= () (tl (tl (tl V1178))))))))
   (cons bind
    (cons (hd (tl V1178))
     (cons (shen-insert_lazyderef (hd (tl (tl V1178)))) ()))))
  ((and (cons? V1178)
    (and (= fwhen (hd V1178))
     (and (cons? (tl V1178)) (= () (tl (tl V1178))))))
   (cons fwhen (cons (shen-insert_lazyderef (hd (tl V1178))) ())))
  ((cons? V1178)
   (cons (shen-m_prolog_to_s-prolog_predicate (hd V1178)) (tl V1178)))
  (true (shen-sys-error shen-s-prolog_literal))))

(defun shen-insert_deref (V1179)
 (cond ((variable? V1179) (cons shen-deref (cons V1179 (cons ProcessN ()))))
  ((cons? V1179)
   (cons (shen-insert_deref (hd V1179)) (shen-insert_deref (tl V1179))))
  (true V1179)))

(defun shen-insert_lazyderef (V1180)
 (cond
  ((variable? V1180) (cons shen-lazyderef (cons V1180 (cons ProcessN ()))))
  ((cons? V1180)
   (cons (shen-insert_lazyderef (hd V1180))
    (shen-insert_lazyderef (tl V1180))))
  (true V1180)))

(defun shen-m_prolog_to_s-prolog_predicate (V1181)
 (cond ((= = V1181) unify) ((= =! V1181) unify!)
  ((= == V1181) identical) (true V1181)))

(defun shen-group_clauses (V1182)
 (cond ((= () V1182) ())
  ((cons? V1182)
   (let Group
    (shen-collect (lambda X (shen-same_predicate? (hd V1182) X)) V1182)
    (let Rest (difference V1182 Group)
     (cons Group (shen-group_clauses Rest)))))
  (true (shen-sys-error shen-group_clauses))))

(defun shen-collect (V1185 V1186)
 (cond ((= () V1186) ())
  ((cons? V1186)
   (if (V1185 (hd V1186)) (cons (hd V1186) (shen-collect V1185 (tl V1186)))
    (shen-collect V1185 (tl V1186))))
  (true (shen-sys-error shen-collect))))

(defun shen-same_predicate? (V1203 V1204)
 (cond
  ((and (cons? V1203)
    (and (cons? (hd V1203)) (and (cons? V1204) (cons? (hd V1204)))))
   (= (hd (hd V1203)) (hd (hd V1204))))
  (true (shen-sys-error shen-same_predicate?))))

(defun shen-compile_prolog_procedure (V1205)
 (let F (shen-procedure_name V1205)
  (let Shen (shen-clauses-to-shen F V1205) Shen)))

(defun shen-procedure_name (V1218)
 (cond
  ((and (cons? V1218) (and (cons? (hd V1218)) (cons? (hd (hd V1218)))))
   (hd (hd (hd V1218))))
  (true (shen-sys-error shen-procedure_name))))

(defun shen-clauses-to-shen (V1219 V1220)
 (let Linear (map (lambda V1221 (shen-linearise-clause V1221)) V1220)
  (let Arity
   (shen-prolog-aritycheck V1219 (map (lambda V1222 (head V1222)) V1220))
   (let Parameters (shen-parameters Arity)
    (let AUM_instructions (map (lambda X (shen-aum X Parameters)) Linear)
     (let Code
      (shen-catch-cut
       (shen-nest-disjunct
        (map (lambda V1223 (shen-aum_to_shen V1223)) AUM_instructions)))
      (let ShenDef
       (cons define
        (cons V1219
         (append Parameters
          (append (cons ProcessN (cons Continuation ()))
           (cons -> (cons Code ()))))))
       ShenDef)))))))

(defun shen-catch-cut (V1224)
 (cond ((not (shen-occurs? cut V1224)) V1224)
  (true
   (cons let
    (cons Throwcontrol
     (cons (cons shen-catchpoint ())
      (cons (cons shen-cutpoint (cons Throwcontrol (cons V1224 ())))
       ())))))))

(defun shen-catchpoint () (set shen-*catch* (+ 1 (value shen-*catch*))))

(defun shen-cutpoint (V1229 V1230)
 (cond ((= V1230 V1229) false) (true V1230)))

(defun shen-nest-disjunct (V1232)
 (cond ((and (cons? V1232) (= () (tl V1232))) (hd V1232))
  ((cons? V1232) (shen-lisp-or (hd V1232) (shen-nest-disjunct (tl V1232))))
  (true (shen-sys-error shen-nest-disjunct))))

(defun shen-lisp-or (V1233 V1234)
 (cons let
  (cons Case
   (cons V1233
    (cons
     (cons if
      (cons (cons = (cons Case (cons false ())))
       (cons V1234 (cons Case ()))))
     ())))))

(defun shen-prolog-aritycheck (V1237 V1238)
 (cond ((and (cons? V1238) (= () (tl V1238))) (- (length (hd V1238)) 1))
  ((and (cons? V1238) (cons? (tl V1238)))
   (if (= (length (hd V1238)) (length (hd (tl V1238))))
    (shen-prolog-aritycheck V1237 (tl V1238))
    (interror "arity error in prolog procedure ~A~%"
     (@p (cons V1237 ()) ()))))
  (true (shen-sys-error shen-prolog-aritycheck))))

(defun shen-linearise-clause (V1239)
 (cond
  ((and (cons? V1239)
    (and (cons? (tl V1239))
     (and (= :- (hd (tl V1239)))
      (and (cons? (tl (tl V1239))) (= () (tl (tl (tl V1239))))))))
   (let Linear (shen-linearise (cons (hd V1239) (tl (tl V1239))))
    (shen-clause_form Linear)))
  (true (shen-sys-error shen-linearise-clause))))

(defun shen-clause_form (V1240)
 (cond
  ((and (cons? V1240) (and (cons? (tl V1240)) (= () (tl (tl V1240)))))
   (cons (shen-explicit_modes (hd V1240))
    (cons :- (cons (shen-cf_help (hd (tl V1240))) ()))))
  (true (shen-sys-error shen-clause_form))))

(defun shen-explicit_modes (V1241)
 (cond
  ((cons? V1241)
   (cons (hd V1241) (map (lambda V1242 (shen-em_help V1242)) (tl V1241))))
  (true (shen-sys-error shen-explicit_modes))))

(defun shen-em_help (V1243)
 (cond
  ((and (cons? V1243)
    (and (= mode (hd V1243))
     (and (cons? (tl V1243))
      (and (cons? (tl (tl V1243))) (= () (tl (tl (tl V1243))))))))
   V1243)
  (true (cons mode (cons V1243 (cons + ()))))))

(defun shen-cf_help (V1244)
 (cond
  ((and (cons? V1244)
    (and (= where (hd V1244))
     (and (cons? (tl V1244))
      (and (cons? (hd (tl V1244)))
       (and (= = (hd (hd (tl V1244))))
        (and (cons? (tl (hd (tl V1244))))
         (and (cons? (tl (tl (hd (tl V1244)))))
          (and (= () (tl (tl (tl (hd (tl V1244))))))
           (and (cons? (tl (tl V1244)))
            (= () (tl (tl (tl V1244)))))))))))))
   (cons (cons (if (value shen-*occurs*) unify! unify) (tl (hd (tl V1244))))
    (shen-cf_help (hd (tl (tl V1244))))))
  (true V1244)))

(defun occurs-check (V1249)
 (cond ((= + V1249) (set shen-*occurs* true))
  ((= - V1249) (set shen-*occurs* false))
  (true (interror "occurs-check expects + or -~%" ()))))

(defun shen-aum (V1250 V1251)
 (cond
  ((and (cons? V1250)
    (and (cons? (hd V1250))
     (and (cons? (tl V1250))
      (and (= :- (hd (tl V1250)))
       (and (cons? (tl (tl V1250))) (= () (tl (tl (tl V1250)))))))))
   (let MuApplication
    (shen-make_mu_application
     (cons shen-mu
      (cons (tl (hd V1250))
       (cons (shen-continuation_call (tl (hd V1250)) (hd (tl (tl V1250))))
        ())))
     V1251)
    (shen-mu_reduction MuApplication +)))
  (true (shen-sys-error shen-aum))))

(defun shen-continuation_call (V1252 V1253)
 (let VTerms (cons ProcessN (shen-extract_vars V1252))
  (let VBody (shen-extract_vars V1253)
   (let Free (remove Throwcontrol (difference VBody VTerms))
    (shen-cc_help Free V1253)))))

(defun remove (V1256 V1257)
 (cond ((= () V1257) ())
  ((and (cons? V1257) (= (hd V1257) V1256)) (remove (hd V1257) (tl V1257)))
  ((cons? V1257) (cons (hd V1257) (remove V1256 (tl V1257))))
  (true (shen-sys-error remove))))

(defun shen-cc_help (V1259 V1260)
 (cond
  ((and (= () V1259) (= () V1260))
   (cons shen-pop (cons shen-the (cons shen-stack ()))))
  ((= () V1260)
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V1259
        (cons and
         (cons shen-then
          (cons (cons shen-pop (cons shen-the (cons shen-stack ())))
           ())))))))))
  ((= () V1259)
   (cons call (cons shen-the (cons shen-continuation (cons V1260 ())))))
  (true
   (cons shen-rename
    (cons shen-the
     (cons shen-variables
      (cons in
       (cons V1259
        (cons and
         (cons shen-then
          (cons
           (cons call
            (cons shen-the (cons shen-continuation (cons V1260 ()))))
           ())))))))))))

(defun shen-make_mu_application (V1261 V1262)
 (cond
  ((and (cons? V1261)
    (and (= shen-mu (hd V1261))
     (and (cons? (tl V1261))
      (and (= () (hd (tl V1261)))
       (and (cons? (tl (tl V1261)))
        (and (= () (tl (tl (tl V1261)))) (= () V1262)))))))
   (hd (tl (tl V1261))))
  ((and (cons? V1261)
    (and (= shen-mu (hd V1261))
     (and (cons? (tl V1261))
      (and (cons? (hd (tl V1261)))
       (and (cons? (tl (tl V1261)))
        (and (= () (tl (tl (tl V1261)))) (cons? V1262)))))))
   (cons
    (cons shen-mu
     (cons (hd (hd (tl V1261)))
      (cons
       (shen-make_mu_application
        (cons shen-mu (cons (tl (hd (tl V1261))) (tl (tl V1261)))) (tl V1262))
       ())))
    (cons (hd V1262) ())))
  (true (shen-sys-error shen-make_mu_application))))

(defun shen-mu_reduction (V1269 V1270)
 (cond
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (hd (tl (hd V1269))))
        (and (= mode (hd (hd (tl (hd V1269)))))
         (and (cons? (tl (hd (tl (hd V1269)))))
          (and (cons? (tl (tl (hd (tl (hd V1269))))))
           (and (= () (tl (tl (tl (hd (tl (hd V1269)))))))
            (and (cons? (tl (tl (hd V1269))))
             (and (= () (tl (tl (tl (hd V1269)))))
              (and (cons? (tl V1269)) (= () (tl (tl V1269)))))))))))))))
   (shen-mu_reduction
    (cons
     (cons shen-mu (cons (hd (tl (hd (tl (hd V1269))))) (tl (tl (hd V1269)))))
     (tl V1269))
    (hd (tl (tl (hd (tl (hd V1269))))))))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (tl (tl (hd V1269))))
        (and (= () (tl (tl (tl (hd V1269)))))
         (and (cons? (tl V1269))
          (and (= () (tl (tl V1269))) (= _ (hd (tl (hd V1269))))))))))))
   (shen-mu_reduction (hd (tl (tl (hd V1269)))) V1270))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (tl (tl (hd V1269))))
        (and (= () (tl (tl (tl (hd V1269)))))
         (and (cons? (tl V1269))
          (and (= () (tl (tl V1269)))
           (shen-ephemeral_variable? (hd (tl (hd V1269)))
            (hd (tl V1269)))))))))))
   (subst (hd (tl V1269)) (hd (tl (hd V1269)))
    (shen-mu_reduction (hd (tl (tl (hd V1269)))) V1270)))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (tl (tl (hd V1269))))
        (and (= () (tl (tl (tl (hd V1269)))))
         (and (cons? (tl V1269))
          (and (= () (tl (tl V1269)))
           (variable? (hd (tl (hd V1269))))))))))))
   (cons let
    (cons (hd (tl (hd V1269)))
     (cons shen-be
      (cons (hd (tl V1269))
       (cons in
        (cons (shen-mu_reduction (hd (tl (tl (hd V1269)))) V1270) ())))))))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (tl (tl (hd V1269))))
        (and (= () (tl (tl (tl (hd V1269)))))
         (and (cons? (tl V1269))
          (and (= () (tl (tl V1269)))
           (and (= - V1270)
            (shen-prolog_constant? (hd (tl (hd V1269)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1269)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V1269))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V1269)))) -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (tl (tl (hd V1269))))
        (and (= () (tl (tl (tl (hd V1269)))))
         (and (cons? (tl V1269))
          (and (= () (tl (tl V1269)))
           (and (= + V1270)
            (shen-prolog_constant? (hd (tl (hd V1269)))))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1269)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is
              (cons identical (cons shen-to (cons (hd (tl (hd V1269))) ())))))
            (cons shen-then
             (cons (shen-mu_reduction (hd (tl (tl (hd V1269)))) +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons bind
                     (cons Z
                      (cons shen-to
                       (cons (hd (tl (hd V1269)))
                        (cons in
                         (cons (shen-mu_reduction (hd (tl (tl (hd V1269)))) +)
                          ()))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (hd (tl (hd V1269))))
        (and (cons? (tl (tl (hd V1269))))
         (and (= () (tl (tl (tl (hd V1269)))))
          (and (cons? (tl V1269))
           (and (= () (tl (tl V1269))) (= - V1270))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1269)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V1269))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V1269)))) (tl (tl (hd V1269)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               -)
              (cons shen-else (cons fail! ()))))))
          ()))))))))
  ((and (cons? V1269)
    (and (cons? (hd V1269))
     (and (= shen-mu (hd (hd V1269)))
      (and (cons? (tl (hd V1269)))
       (and (cons? (hd (tl (hd V1269))))
        (and (cons? (tl (tl (hd V1269))))
         (and (= () (tl (tl (tl (hd V1269)))))
          (and (cons? (tl V1269))
           (and (= () (tl (tl V1269))) (= + V1270))))))))))
   (let Z (gensym V)
    (cons let
     (cons Z
      (cons shen-be
       (cons
        (cons shen-the
         (cons shen-result
          (cons shen-of (cons shen-dereferencing (tl V1269)))))
        (cons in
         (cons
          (cons if
           (cons
            (cons Z
             (cons is (cons shen-a (cons shen-non-empty (cons list ())))))
            (cons shen-then
             (cons
              (shen-mu_reduction
               (cons
                (cons shen-mu
                 (cons (hd (hd (tl (hd V1269))))
                  (cons
                   (cons
                    (cons shen-mu
                     (cons (tl (hd (tl (hd V1269)))) (tl (tl (hd V1269)))))
                    (cons
                     (cons shen-the (cons tail (cons shen-of (cons Z ()))))
                     ()))
                   ())))
                (cons (cons shen-the (cons head (cons shen-of (cons Z ()))))
                 ()))
               +)
              (cons shen-else
               (cons
                (cons if
                 (cons
                  (cons Z (cons is (cons shen-a (cons shen-variable ()))))
                  (cons shen-then
                   (cons
                    (cons shen-rename
                     (cons shen-the
                      (cons shen-variables
                       (cons in
                        (cons (shen-extract_vars (hd (tl (hd V1269))))
                         (cons and
                          (cons shen-then
                           (cons
                            (cons bind
                             (cons Z
                              (cons shen-to
                               (cons
                                (shen-rcons_form
                                 (shen-remove_modes (hd (tl (hd V1269)))))
                                (cons in
                                 (cons
                                  (shen-mu_reduction (hd (tl (tl (hd V1269))))
                                   +)
                                  ()))))))
                            ()))))))))
                    (cons shen-else (cons fail! ()))))))
                ()))))))
          ()))))))))
  (true V1269)))

(defun shen-rcons_form (V1271)
 (cond
  ((cons? V1271)
   (cons cons
    (cons (shen-rcons_form (hd V1271))
     (cons (shen-rcons_form (tl V1271)) ()))))
  (true V1271)))

(defun shen-remove_modes (V1272)
 (cond
  ((and (cons? V1272)
    (and (= mode (hd V1272))
     (and (cons? (tl V1272))
      (and (cons? (tl (tl V1272)))
       (and (= + (hd (tl (tl V1272)))) (= () (tl (tl (tl V1272)))))))))
   (shen-remove_modes (hd (tl V1272))))
  ((and (cons? V1272)
    (and (= mode (hd V1272))
     (and (cons? (tl V1272))
      (and (cons? (tl (tl V1272)))
       (and (= - (hd (tl (tl V1272)))) (= () (tl (tl (tl V1272)))))))))
   (shen-remove_modes (hd (tl V1272))))
  ((cons? V1272)
   (cons (shen-remove_modes (hd V1272)) (shen-remove_modes (tl V1272))))
  (true V1272)))

(defun shen-ephemeral_variable? (V1273 V1274)
 (and (variable? V1273) (variable? V1274)))

(defun shen-prolog_constant? (V1283) (cond ((cons? V1283) false) (true true)))

(defun shen-aum_to_shen (V1284)
 (cond
  ((and (cons? V1284)
    (and (= let (hd V1284))
     (and (cons? (tl V1284))
      (and (cons? (tl (tl V1284)))
       (and (= shen-be (hd (tl (tl V1284))))
        (and (cons? (tl (tl (tl V1284))))
         (and (cons? (tl (tl (tl (tl V1284)))))
          (and (= in (hd (tl (tl (tl (tl V1284))))))
           (and (cons? (tl (tl (tl (tl (tl V1284))))))
            (= () (tl (tl (tl (tl (tl (tl V1284))))))))))))))))
   (cons let
    (cons (hd (tl V1284))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V1284)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1284))))))) ())))))
  ((and (cons? V1284)
    (and (= shen-the (hd V1284))
     (and (cons? (tl V1284))
      (and (= shen-result (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-of (hd (tl (tl V1284))))
         (and (cons? (tl (tl (tl V1284))))
          (and (= shen-dereferencing (hd (tl (tl (tl V1284)))))
           (and (cons? (tl (tl (tl (tl V1284)))))
            (= () (tl (tl (tl (tl (tl V1284)))))))))))))))
   (cons shen-lazyderef
    (cons (shen-aum_to_shen (hd (tl (tl (tl (tl V1284))))))
     (cons ProcessN ()))))
  ((and (cons? V1284)
    (and (= if (hd V1284))
     (and (cons? (tl V1284))
      (and (cons? (tl (tl V1284)))
       (and (= shen-then (hd (tl (tl V1284))))
        (and (cons? (tl (tl (tl V1284))))
         (and (cons? (tl (tl (tl (tl V1284)))))
          (and (= shen-else (hd (tl (tl (tl (tl V1284))))))
           (and (cons? (tl (tl (tl (tl (tl V1284))))))
            (= () (tl (tl (tl (tl (tl (tl V1284))))))))))))))))
   (cons if
    (cons (shen-aum_to_shen (hd (tl V1284)))
     (cons (shen-aum_to_shen (hd (tl (tl (tl V1284)))))
      (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1284))))))) ())))))
  ((and (cons? V1284)
    (and (cons? (tl V1284))
     (and (= is (hd (tl V1284)))
      (and (cons? (tl (tl V1284)))
       (and (= shen-a (hd (tl (tl V1284))))
        (and (cons? (tl (tl (tl V1284))))
         (and (= shen-variable (hd (tl (tl (tl V1284)))))
          (= () (tl (tl (tl (tl V1284))))))))))))
   (cons shen-pvar? (cons (hd V1284) ())))
  ((and (cons? V1284)
    (and (cons? (tl V1284))
     (and (= is (hd (tl V1284)))
      (and (cons? (tl (tl V1284)))
       (and (= shen-a (hd (tl (tl V1284))))
        (and (cons? (tl (tl (tl V1284))))
         (and (= shen-non-empty (hd (tl (tl (tl V1284)))))
          (and (cons? (tl (tl (tl (tl V1284)))))
           (and (= list (hd (tl (tl (tl (tl V1284))))))
            (= () (tl (tl (tl (tl (tl V1284)))))))))))))))
   (cons cons? (cons (hd V1284) ())))
  ((and (cons? V1284)
    (and (= shen-rename (hd V1284))
     (and (cons? (tl V1284))
      (and (= shen-the (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-variables (hd (tl (tl V1284))))
         (and (cons? (tl (tl (tl V1284))))
          (and (= in (hd (tl (tl (tl V1284)))))
           (and (cons? (tl (tl (tl (tl V1284)))))
            (and (= () (hd (tl (tl (tl (tl V1284))))))
             (and (cons? (tl (tl (tl (tl (tl V1284))))))
              (and (= and (hd (tl (tl (tl (tl (tl V1284)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V1284)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V1284))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V1284))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V1284))))))))))))))))))))))))
   (shen-aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1284))))))))))
  ((and (cons? V1284)
    (and (= shen-rename (hd V1284))
     (and (cons? (tl V1284))
      (and (= shen-the (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-variables (hd (tl (tl V1284))))
         (and (cons? (tl (tl (tl V1284))))
          (and (= in (hd (tl (tl (tl V1284)))))
           (and (cons? (tl (tl (tl (tl V1284)))))
            (and (cons? (hd (tl (tl (tl (tl V1284))))))
             (and (cons? (tl (tl (tl (tl (tl V1284))))))
              (and (= and (hd (tl (tl (tl (tl (tl V1284)))))))
               (and (cons? (tl (tl (tl (tl (tl (tl V1284)))))))
                (and (= shen-then (hd (tl (tl (tl (tl (tl (tl V1284))))))))
                 (and (cons? (tl (tl (tl (tl (tl (tl (tl V1284))))))))
                  (= ()
                   (tl
                    (tl (tl (tl (tl (tl (tl (tl V1284))))))))))))))))))))))))
   (cons let
    (cons (hd (hd (tl (tl (tl (tl V1284))))))
     (cons (cons shen-newpv (cons ProcessN ()))
      (cons
       (shen-aum_to_shen
        (cons shen-rename
         (cons shen-the
          (cons shen-variables
           (cons in
            (cons (tl (hd (tl (tl (tl (tl V1284))))))
             (tl (tl (tl (tl (tl V1284)))))))))))
       ())))))
  ((and (cons? V1284)
    (and (= bind (hd V1284))
     (and (cons? (tl V1284))
      (and (cons? (tl (tl V1284)))
       (and (= shen-to (hd (tl (tl V1284))))
        (and (cons? (tl (tl (tl V1284))))
         (and (cons? (tl (tl (tl (tl V1284)))))
          (and (= in (hd (tl (tl (tl (tl V1284))))))
           (and (cons? (tl (tl (tl (tl (tl V1284))))))
            (= () (tl (tl (tl (tl (tl (tl V1284))))))))))))))))
   (cons do
    (cons
     (cons shen-bindv
      (cons (hd (tl V1284))
       (cons (shen-chwild (hd (tl (tl (tl V1284))))) (cons ProcessN ()))))
     (cons
      (cons let
       (cons Result
        (cons (shen-aum_to_shen (hd (tl (tl (tl (tl (tl V1284)))))))
         (cons
          (cons do
           (cons (cons shen-unbindv (cons (hd (tl V1284)) (cons ProcessN ())))
            (cons Result ())))
          ()))))
      ()))))
  ((and (cons? V1284)
    (and (cons? (tl V1284))
     (and (= is (hd (tl V1284)))
      (and (cons? (tl (tl V1284)))
       (and (= identical (hd (tl (tl V1284))))
        (and (cons? (tl (tl (tl V1284))))
         (and (= shen-to (hd (tl (tl (tl V1284)))))
          (and (cons? (tl (tl (tl (tl V1284)))))
           (= () (tl (tl (tl (tl (tl V1284))))))))))))))
   (cons = (cons (hd (tl (tl (tl (tl V1284))))) (cons (hd V1284) ()))))
  ((= fail! V1284) false)
  ((and (cons? V1284)
    (and (= shen-the (hd V1284))
     (and (cons? (tl V1284))
      (and (= head (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-of (hd (tl (tl V1284))))
         (and (cons? (tl (tl (tl V1284))))
          (= () (tl (tl (tl (tl V1284))))))))))))
   (cons hd (tl (tl (tl V1284)))))
  ((and (cons? V1284)
    (and (= shen-the (hd V1284))
     (and (cons? (tl V1284))
      (and (= tail (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-of (hd (tl (tl V1284))))
         (and (cons? (tl (tl (tl V1284))))
          (= () (tl (tl (tl (tl V1284))))))))))))
   (cons tl (tl (tl (tl V1284)))))
  ((and (cons? V1284)
    (and (= shen-pop (hd V1284))
     (and (cons? (tl V1284))
      (and (= shen-the (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-stack (hd (tl (tl V1284))))
         (= () (tl (tl (tl V1284))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons (cons thaw (cons Continuation ())) ()))))
  ((and (cons? V1284)
    (and (= call (hd V1284))
     (and (cons? (tl V1284))
      (and (= shen-the (hd (tl V1284)))
       (and (cons? (tl (tl V1284)))
        (and (= shen-continuation (hd (tl (tl V1284))))
         (and (cons? (tl (tl (tl V1284))))
          (= () (tl (tl (tl (tl V1284))))))))))))
   (cons do
    (cons (cons shen-incinfs ())
     (cons
      (shen-call_the_continuation (shen-chwild (hd (tl (tl (tl V1284)))))
       ProcessN Continuation)
      ()))))
  (true V1284)))

(defun shen-chwild (V1285)
 (cond ((= V1285 _) (cons shen-newpv (cons ProcessN ())))
  ((cons? V1285) (map (lambda V1286 (shen-chwild V1286)) V1285)) (true V1285)))

(defun shen-newpv (V1287)
 (let Count+1 (+ (<-address (value shen-*varcounter*) V1287) 1)
  (let IncVar (address-> (value shen-*varcounter*) V1287 Count+1)
   (let Vector (<-address (value shen-*prologvectors*) V1287)
    (let ResizeVectorIfNeeded
     (if (= Count+1 (limit Vector)) (shen-resizeprocessvector V1287 Count+1)
      shen-skip)
     (shen-mk-pvar Count+1))))))

(defun shen-resizeprocessvector (V1288 V1289)
 (let Vector (<-address (value shen-*prologvectors*) V1288)
  (let BigVector (shen-resize-vector Vector (+ V1289 V1289) shen--null-)
   (address-> (value shen-*prologvectors*) V1288 BigVector))))

(defun shen-resize-vector (V1290 V1291 V1292)
 (let BigVector (address-> (absvector (+ 1 V1291)) 0 V1291)
  (shen-copy-vector V1290 BigVector (limit V1290) V1291 V1292)))

(defun shen-copy-vector (V1293 V1294 V1295 V1296 V1297)
 (shen-copy-vector-stage-2 (+ 1 V1295) (+ V1296 1) V1297
  (shen-copy-vector-stage-1 1 V1293 V1294 (+ 1 V1295))))

(defun shen-copy-vector-stage-1 (V1300 V1301 V1302 V1303)
 (cond ((= V1303 V1300) V1302)
  (true
   (shen-copy-vector-stage-1 (+ 1 V1300) V1301
    (address-> V1302 V1300 (<-address V1301 V1300)) V1303))))

(defun shen-copy-vector-stage-2 (V1307 V1308 V1309 V1310)
 (cond ((= V1308 V1307) V1310)
  (true
   (shen-copy-vector-stage-2 (+ V1307 1) V1308 V1309
    (address-> V1310 V1307 V1309)))))

(defun shen-mk-pvar (V1312)
 (address-> (address-> (absvector 2) 0 shen-pvar) 1 V1312))

(defun shen-pvar? (V1313)
 (and (absvector? V1313) (= (<-address V1313 0) shen-pvar)))

(defun shen-bindv (V1314 V1315 V1316)
 (let Vector (<-address (value shen-*prologvectors*) V1316)
  (address-> Vector (<-address V1314 1) V1315)))

(defun shen-unbindv (V1317 V1318)
 (let Vector (<-address (value shen-*prologvectors*) V1318)
  (address-> Vector (<-address V1317 1) shen--null-)))

(defun shen-incinfs () (set shen-*infs* (+ 1 (value shen-*infs*))))

(defun shen-call_the_continuation (V1319 V1320 V1321)
 (cond
  ((and (cons? V1319) (and (cons? (hd V1319)) (= () (tl V1319))))
   (cons (hd (hd V1319))
    (append (tl (hd V1319)) (cons V1320 (cons V1321 ())))))
  ((and (cons? V1319) (cons? (hd V1319)))
   (let NewContinuation (shen-newcontinuation (tl V1319) V1320 V1321)
    (cons (hd (hd V1319))
     (append (tl (hd V1319)) (cons V1320 (cons NewContinuation ()))))))
  (true (shen-sys-error shen-call_the_continuation))))

(defun shen-newcontinuation (V1322 V1323 V1324)
 (cond ((= () V1322) V1324)
  ((and (cons? V1322) (cons? (hd V1322)))
   (cons freeze
    (cons
     (cons (hd (hd V1322))
      (append (tl (hd V1322))
       (cons V1323 (cons (shen-newcontinuation (tl V1322) V1323 V1324) ()))))
     ())))
  (true (shen-sys-error shen-newcontinuation))))

(defun return (V1329 V1330 V1331) (shen-deref V1329 V1330))

(defun shen-measure&return (V1336 V1337 V1338)
 (do (intoutput "~A inferences~%" (@p (value shen-*infs*) ()))
  (shen-deref V1336 V1337)))

(defun unify (V1339 V1340 V1341 V1342)
 (shen-lzy= (shen-lazyderef V1339 V1341) (shen-lazyderef V1340 V1341) V1341
  V1342))

(defun shen-lzy= (V1359 V1360 V1361 V1362)
 (cond ((= V1360 V1359) (thaw V1362))
  ((shen-pvar? V1359) (bind V1359 V1360 V1361 V1362))
  ((shen-pvar? V1360) (bind V1360 V1359 V1361 V1362))
  ((and (cons? V1359) (cons? V1360))
   (shen-lzy= (shen-lazyderef (hd V1359) V1361)
    (shen-lazyderef (hd V1360) V1361) V1361
    (freeze
     (shen-lzy= (shen-lazyderef (tl V1359) V1361)
      (shen-lazyderef (tl V1360) V1361) V1361 V1362))))
  (true false)))

(defun shen-deref (V1364 V1365)
 (cond
  ((cons? V1364)
   (cons (shen-deref (hd V1364) V1365) (shen-deref (tl V1364) V1365)))
  (true
   (if (shen-pvar? V1364)
    (let Value (shen-valvector V1364 V1365)
     (if (= Value shen--null-) V1364 (shen-deref Value V1365)))
    V1364))))

(defun shen-lazyderef (V1366 V1367)
 (if (shen-pvar? V1366)
  (let Value (shen-valvector V1366 V1367)
   (if (= Value shen--null-) V1366 (shen-lazyderef Value V1367)))
  V1366))

(defun shen-valvector (V1368 V1369)
 (<-address (<-address (value shen-*prologvectors*) V1369)
  (<-address V1368 1)))

(defun unify! (V1370 V1371 V1372 V1373)
 (shen-lzy=! (shen-lazyderef V1370 V1372) (shen-lazyderef V1371 V1372) V1372
  V1373))

(defun shen-lzy=! (V1390 V1391 V1392 V1393)
 (cond ((= V1391 V1390) (thaw V1393))
  ((and (shen-pvar? V1390) (not (shen-occurs? V1390 (shen-deref V1391 V1392))))
   (bind V1390 V1391 V1392 V1393))
  ((and (shen-pvar? V1391) (not (shen-occurs? V1391 (shen-deref V1390 V1392))))
   (bind V1391 V1390 V1392 V1393))
  ((and (cons? V1390) (cons? V1391))
   (shen-lzy=! (shen-lazyderef (hd V1390) V1392)
    (shen-lazyderef (hd V1391) V1392) V1392
    (freeze
     (shen-lzy=! (shen-lazyderef (tl V1390) V1392)
      (shen-lazyderef (tl V1391) V1392) V1392 V1393))))
  (true false)))

(defun shen-occurs? (V1403 V1404)
 (cond ((= V1404 V1403) true)
  ((cons? V1404)
   (or (shen-occurs? V1403 (hd V1404)) (shen-occurs? V1403 (tl V1404))))
  (true false)))

(defun identical (V1406 V1407 V1408 V1409)
 (shen-lzy== (shen-lazyderef V1406 V1408) (shen-lazyderef V1407 V1408) V1408
  V1409))

(defun shen-lzy== (V1426 V1427 V1428 V1429)
 (cond ((= V1427 V1426) (thaw V1429))
  ((and (cons? V1426) (cons? V1427))
   (shen-lzy== (shen-lazyderef (hd V1426) V1428)
    (shen-lazyderef (hd V1427) V1428) V1428
    (freeze (shen-lzy== (tl V1426) (tl V1427) V1428 V1429))))
  (true false)))

(defun shen-pvar (V1431) (intmake-string "Var~A" (@p (<-address V1431 1) ())))

(defun bind (V1432 V1433 V1434 V1435)
 (do (shen-bindv V1432 V1433 V1434)
  (let Result (thaw V1435) (do (shen-unbindv V1432 V1434) Result))))

(defun fwhen (V1450 V1451 V1452)
 (cond ((= true V1450) (thaw V1452)) ((= false V1450) false)
  (true (interror "fwhen expects a boolean: not ~S%" (@p V1450 ())))))

(defun call (V1465 V1466 V1467)
 (cond
  ((cons? V1465)
   (shen-call-help
    (shen-m_prolog_to_s-prolog_predicate (shen-lazyderef (hd V1465) V1466))
    (tl V1465) V1466 V1467))
  (true false)))

(defun shen-call-help (V1468 V1469 V1470 V1471)
 (cond ((= () V1469) (V1468 V1470 V1471))
  ((cons? V1469) (shen-call-help (V1468 (hd V1469)) (tl V1469) V1470 V1471))
  (true (shen-sys-error shen-call-help))))

(defun shen-intprolog (V1472)
 (cond
  ((and (cons? V1472) (cons? (hd V1472)))
   (let ProcessN (shen-start-new-prolog-process)
    (shen-intprolog-help (hd (hd V1472))
     (shen-insert-prolog-variables (cons (tl (hd V1472)) (cons (tl V1472) ()))
      ProcessN)
     ProcessN)))
  (true (shen-sys-error shen-intprolog))))

(defun shen-intprolog-help (V1473 V1474 V1475)
 (cond
  ((and (cons? V1474) (and (cons? (tl V1474)) (= () (tl (tl V1474)))))
   (shen-intprolog-help-help V1473 (hd V1474) (hd (tl V1474)) V1475))
  (true (shen-sys-error shen-intprolog-help))))

(defun shen-intprolog-help-help (V1476 V1477 V1478 V1479)
 (cond ((= () V1477) (V1476 V1479 (freeze (shen-call-rest V1478 V1479))))
  ((cons? V1477)
   (shen-intprolog-help-help (V1476 (hd V1477)) (tl V1477) V1478 V1479))
  (true (shen-sys-error shen-intprolog-help-help))))

(defun shen-call-rest (V1482 V1483)
 (cond ((= () V1482) true)
  ((and (cons? V1482) (and (cons? (hd V1482)) (cons? (tl (hd V1482)))))
   (shen-call-rest
    (cons (cons ((hd (hd V1482)) (hd (tl (hd V1482)))) (tl (tl (hd V1482))))
     (tl V1482))
    V1483))
  ((and (cons? V1482) (and (cons? (hd V1482)) (= () (tl (hd V1482)))))
   ((hd (hd V1482)) V1483 (freeze (shen-call-rest (tl V1482) V1483))))
  (true (shen-sys-error shen-call-rest))))

(defun shen-start-new-prolog-process ()
 (let IncrementProcessCounter
  (set shen-*process-counter* (+ 1 (value shen-*process-counter*)))
  (shen-initialise-prolog IncrementProcessCounter)))

(defun shen-insert-prolog-variables (V1484 V1485)
 (shen-insert-prolog-variables-help V1484 (shen-flatten V1484) V1485))

(defun shen-insert-prolog-variables-help (V1490 V1491 V1492)
 (cond ((= () V1491) V1490)
  ((and (cons? V1491) (variable? (hd V1491)))
   (let V (shen-newpv V1492)
    (let XV/Y (subst V (hd V1491) V1490)
     (let Z-Y (remove (hd V1491) (tl V1491))
      (shen-insert-prolog-variables-help XV/Y Z-Y V1492)))))
  ((cons? V1491) (shen-insert-prolog-variables-help V1490 (tl V1491) V1492))
  (true (shen-sys-error shen-insert-prolog-variables-help))))

(defun shen-initialise-prolog (V1493)
 (let Vector
  (address-> (value shen-*prologvectors*) V1493
   (shen-fillvector (vector 10) 1 11 shen--null-))
  (let Counter (address-> (value shen-*varcounter*) V1493 1) V1493)))

